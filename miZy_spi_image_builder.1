#!/usr/bin/perl

## hyphop ##

=head1 ABOUT miZy_spi_image_builder

SPI-flash firmware image builder (for sunxi Orange Pi Zero, another sunxi boards maybe work too )

Its just a part or miZy project, and same as other our parts can standalone used

This perl script no need any libs or another deps

=head1 USAGE

help

    ./miZy_spi_image_builder --help

common usage for 8M image, output to out/orange_pi_zero_hyphop_mizy_spi_flash_demo-8M.bin

    ./miZy_spi_image_builder

custom config

    ./miZy_spi_image_builder miZy-spi_image_builder_custom.conf

set 16M image size

    img_size=16M ./miZy_spi_image_builder

not padded by flash size, save only used space

    img_size=0 ./miZy_spi_image_builder

override image out name

    img_name=out/my_image_name%s.bin ./miZy_spi_image_builder

check build status in shell 

    ./miZy_spi_image_builder && echo "build ok"
    ./miZy_spi_image_builder || echo "build fail"

=head1 CONFIG FILE

default config

    miZy-spi_image_builder.conf

config file its a same pure perl code!

=head1 PATHS
    
put your files (uboot scripts env fex/dtc kernel squashfs initramfs userdata) in @SCAN_PATH dirs
by default are

    .
    ./bin
    ./bin.local

=head1 miZy

tiny fast embedded linux, for sunxi Orange Pi Zero (and maybe other boards) and mods.
Now under active development, but is usable already )

=head1 write image into device

in FEL mode via sunxi-fel tools

check spi flash size

    ./tools/fel_spi_info
    Manufacturer: Winbond (EFh), model: 40h, size: 16777216 bytes.

ok! write image - u can write any image size <= flash size

    ./tools/fel_spi_write firmwares/orange_pi_zero_hyphop_mizy_spi_flash_demo-8M.bin

=head1 LINKS

=over

=item *
L<https://github.com/hyphop/miZy_spi_image_builder>

=item *
L<https://hyphop.github.io/mizy/>

=item *
L<https://github.com/hyphop/miZy-uboot>

=item *
L<https://github.com/hyphop/miZy-linux-kernel>

=back

=cut

our ( @SCAN_PATH, @IMG, $block_size, $img_size, $img_name, $script_padded_size,
    $NOW, $env_spi_generate, %mtd_name_uboot_read_size, @env_spi_mtd_parts,
    $env_spi_mtd_parts,
    $MMC_BS, $MMC_OFFSET, %mmc_name_uboot_read_size, %mmc_name_uboot_read_offset,
    $spi_image, $mmc_image
     );

BEGIN {

    ## developer part code 
    our $NOW = localtime();
    if ( ( join "" => @ARGV ) =~ /--md/ ) { 
    `perldoc -o Markdown "$0" > "$0.md"`; exit 0 }
    if ( ( join " " => @ARGV ) =~ /(--push\s*)/ ) {
	my $msg=$'; $msg||=$NOW;
	`$0 --md; git add -A && git commit -m "$msg" && git push`;
	exit 0;
    }

    ## real code start there
    exec perldoc => $0 if ( join "" => @ARGV ) =~ /-{1,2}h(elp)?/;

    our $CONF      = shift;
    our $PROG      = $0;
    our $PROG_NAME = $0;
    $PROG_NAME =~ s{(.+/)}{}sg;
    our $PROG_DIR = $1;
    $CONF ||= "$PROG.conf";
    warn "[i] $PROG_DIR $PROG_NAME => CONF: $CONF\n";

    #    my $CONF_OK = eval { require $CONF };
    do $CONF;
    $CONF_OK = 1;

    unless ($CONF_OK) {
        warn "[e] bad config $CONF\n";
        exit 1;
    }

}

# use only for check
# use common::sense;

our $WARN = "";
our $ERR  = 0;

sub WARN {
    #syswrite STDERR, join "" => @_;
    $WARN .= join "" => @_;
}

sub DIE {
    $ERR = shift;
    warn @_;
    die
}

END {
    syswrite STDERR, $WARN;
    syswrite STDERR, "ERR: $ERR\n" if $ERR;
    exit $ERR;
}

$SIG{'__WARN__'} = \&WARN;

sub getfile {
    my $f;
    my $r;
    my $data;
    $r = open $f, $_[0];
    return undef unless $r;
    my $l = -s $_[0];
    $r = sysread $f, $data, $l;
    warn "[i] readed $r($l) bytes from $_[0]\n";
    return $data;
}

sub savefile {
    my $f;
    my $r = open $f, ">$_[1]";
    return undef unless $r;
    my $l = length $_[0];
    $r = syswrite $f, $_[0], $l;
    warn "[i] save $_[1] $l bytes\n";
    return $r;
}

sub pad {

    #$_[0], $_[1], $_[2];
    my $l = length $_[0];
    my $s = $_[1];
    my $c = $_[2];
    $c ||= "\x00";
    my $p = $s - $l;
    warn "[i] pad $l + $p => $s\n";
    $_[0] . ${c} x $p

}

our %FILES = ();

sub scan_file {
    return $FILES{ $_[0] } if defined $FILES{ $_[0] };
    local $_;
    for (@SCAN_PATH) {
        my $e = -f "$_/$_[0]";
        if ($e) {
            return $FILES{ $_[0] } = "$_/$_[0]";
            break;
        }
    }
    return undef;
}

sub cat {
    my $s = "";
    $s .= getfile( scan_file $_ ) for @_;

    #    $s .= getfile($_) for @_;
    return $s;
}

$block_size //= 65536;

our $out;

printf STDERR "[i] %s bytes => %s\n" => $img_size => $img_name;
printf STDERR "[i] %12s 0x%08s(%9s){%8s} %s\n" =>
  qw/MTD_PART HEX_SIZE DEC_SIZE USED_SZ FILES/;

our $img_size_bytes = tobytes($img_size);
our $env_spi_content = "# auto generated by $0 - $NOW\n";
our $env_files;
our $out_env_start;
our $out_env_end;

DIE 1 => "[e] image size $img_size_bytes not div by $block_size block size\n"
    if $img_size_bytes % $block_size;

our $mmc = $MMC_OFFSET;

## mmc 
##
##
for my $part (@IMG) {

    my $part_name = shift @$part;
    my $part_size = shift @$part;

    #$part

    my $files = join " " => @$part;
    my $used_size = 0;

    for my $file (@$part) {

        my $filepath = scan_file($file);

        unless ( -f $filepath ) {
            DIE 2 =>  "[e] file \"$filepath\" not found\n";
        }

        $used_size += -s $filepath;

    }

    if ($part_size) {

	DIE 3 => "[e] part $part_size size not div by $block_size block size\n"
        if $part_size % $block_size;

	DIE 4 => "[e] part $part_name $part_size < $used_size".
		 " needed for $files, try fix config\n"
        if $used_size > $part_size;

    }
    else {
        $part_size = int( $used_size / $block_size ) * $block_size;
        $part_size ||= $block_size;
    }

    # 524288 + 8192 = 532480 / 512 = 1040

    if ( $part_name eq "uboot" ) {
	$env_spi_content .= sprintf "%s=%x\n", 
		script_ob => ( $MMC_OFFSET + $part_size ) / $MMC_BS;
	$env_spi_content .= sprintf "%s=%x\n", 
		script_sb => 8192 / $MMC_BS;
	$env_spi_content .= sprintf "%s=%x\n", 
		env_ob => ( $MMC_OFFSET + $part_size + 4096) / $MMC_BS;
	$env_spi_content .= sprintf "%s=%x\n", 
		env_sb => 4096 / $MMC_BS;
    }

    if ( $part_name eq "script" ) {
        $out .=  pad( mkimage_header() . cat( shift @$part ) => $script_padded_size => "\x00" );
	$out_env_start = length $out;
	$env_files = $part;
	$out .=  pad( cat(@$part), ($part_size-$script_padded_size) => "\x00");
	$out_env_end = length $out;

    }
    else {

        $out .= pad cat(@$part) => $part_size => "\xFF";

	if ( $env_spi_generate ) {

#~ 
#~ # 512+128+3072+4224 = 7936
#~ mtd=mtdparts=W25q128-flash.0:512k(uboot),64k(script),64k(dtb),3072k(kernel),4224k(initrd),64k(user),8192k@0(8M),-@0(full)
#~ kernel_size=     3200000
#~ ramdisk_size=    2200000
#~ ramdisk_size=    4000000
#~ fdt_size=        65536
#~ 
#~ bootfrom=spi
#~ 
#~ #end


	    my $s = $mtd_name_uboot_read_size{$part_name};

            if ($s) {
                $env_spi_content .= sprintf "%s=%d\n",
                  $s->[0] => $s->[1] ? $used_size : $part_size;
            }

            $s = $mmc_name_uboot_read_size{$part_name};

            if ($s) {
                my $real_size = $s->[1] ? $used_size : $part_size;
                my $fsize     = $real_size / $MMC_BS;
                my $isize     = int $fsize;
                $isize++ unless $fsize == $isize;
                $env_spi_content .= sprintf "%s=%x\n", $s->[0] => $isize;
            }

            $s = $mmc_name_uboot_read_offset{$part_name};

            if ($s) {
                $env_spi_content .= sprintf "%s=%x\n", $s, $mmc / $MMC_BS;
            }

	    push @env_spi_mtd_parts => sprintf "%sk(%s)" => $part_size/1024, $part_name;

	}
    }

    printf STDOUT "[i] %12s 0x%08X(%9s){%8s} $files\n" => $part_name,
      $part_size, $part_size, $used_size, $files;

    $mmc+=$part_size;

}

sub kilo {
    int( $_[0] / 1024 );
}

sub tobytes {
    return $1 * 1024 * 1024 if $_[0] =~ /(\d+)M/;
    return $1 * 1024 if $_[0] =~ /(\d+)K/;
}

sub mkimage_header {

    # uboot script mkimake header
    pack "H*" => join /\s+/ => qw/
      27051956515b32295891963900000fc000000000000000009cfe4d7c0502060000000000
      0000000000000000000000000000000000000000000000000000000000000fb800000000
      /;
}

our $out_size = length $out;

unless ($img_size_bytes) {
    warn "[i] write $img_size_bytes not padder by flash size\n";
}
else {
    if ( $out_size > $img_size_bytes ) {
        DIE 5 =>
          "[e] out size $out_size > $img_size ($img_size_bytes)\n";
    }
    else {
        $out = pad( $out => $img_size_bytes );
    }
}


if ($env_spi_generate) {

    $env_spi_content .=
      $env_spi_mtd_parts . join "," => @env_spi_mtd_parts => '-@0(full)';
    $env_spi_content .= "\n";

    #   $env_spi_content .= "bootfrom=spi\n#end\n";
    #   $env_spi_content .= "bootfrom=MMC\n#end\n";
    $env_spi_content .= "\n#end\n";

    my $env_sz = $out_env_end - $out_env_start;
    my $oe     = pop @$env_files;                 #

    substr $out, $out_env_start, $env_sz,
      pad( cat(@$env_files) . $env_spi_content, $env_sz => "\x00" );

    warn "[i] override env ($oe) =>\n$env_spi_content";

}

if ($spi_image) {
    our $img_spi_name = sprintf $img_name, $img_size;
    savefile( $out => $img_spi_name )
      or DIE 6 => "[e] write error $img_spi_name\n";
}

if ($mmc_image) {

    ## 512 * 2048 = 1048576
    ## 512 * 2048 * 8 = 8388608
    ## 2048 * 8  = 16384
    ## NOW add partitions
    #dd if=/dev/zero bs=1M count=1 >> orange_pi_zero_hyphop_mizy_spi_flash_demo-8M+8192-mmc.bin 
    
    our $img_mmc_name = sprintf $img_name, "$img_size+$MMC_OFFSET", "-mmc";
    our $mmc_boot="\x00" x $MMC_OFFSET;
    #440 +
    our $out_mmc = $mmc_boot . $out;
    savefile( $out_mmc => $img_mmc_name )
      or DIE 6 => "[e] write error $img_mmc_name\n";
}


__END__

=head1 output EXAMPLE : MMC=1 ./miZy_spi_image_builder

root@sager:/tmp/zero_builder/miZy-spi-image-builder# MMC=1 ./miZy_spi_image_builder 
[i] ./ miZy_spi_image_builder => CONF: ./miZy_spi_image_builder.conf
[i] 8M bytes => firmwares/orange_pi_zero_hyphop_mizy_spi_flash_demo-%s%s.bin
[i]     MTD_PART 0xHEX_SIZE( DEC_SIZE){ USED_SZ} FILES
[i]        uboot 0x00080000(   524288){  463478} u-boot-mizi.bin
[i]       script 0x00010000(    65536){    5828} boot.all.cmd boot.all.env boot.spi.env
[i]          dtb 0x00010000(    65536){   34364} orangepizero.bin
[i]       kernel 0x00300000(  3145728){ 3087870} uImage.lzma
[i]       initrd 0x00420000(  4325376){ 2170944} uinitrd.sfs
[i]         user 0x00010000(    65536){       0} 
[i] readed 463478(463478) bytes from bin.local/u-boot-mizi.bin
[i] pad 463478 + 60810 => 524288
[i] readed 3455(3455) bytes from bin.local/boot.all.cmd
[i] pad 3527 + 569 => 4096
[i] readed 2011(2011) bytes from bin.local/boot.all.env
[i] readed 362(362) bytes from bin.local/boot.spi.env
[i] pad 2373 + 59067 => 61440
[i] readed 34364(34364) bytes from bin.local/orangepizero.bin
[i] pad 34364 + 31172 => 65536
[i] readed 3087870(3087870) bytes from bin.local/uImage.lzma
[i] pad 3087870 + 57858 => 3145728
[i] readed 2170944(2170944) bytes from bin.local/uinitrd.sfs
[i] pad 2170944 + 2154432 => 4325376
[i] pad 0 + 65536 => 65536
[i] pad 8192000 + 196608 => 8388608
[i] readed 2011(2011) bytes from bin.local/boot.all.env
[i] pad 2372 + 59068 => 61440
[i] override env (boot.spi.env) =>
# auto generated by ./miZy_spi_image_builder - Wed Apr  5 12:26:18 2017
script_ob=410
script_sb=10
env_ob=418
env_sb=8
fdt_size=65536
fdt_sb=80
fdt_ob=490
kernel_size=3087870
kernel_sb=178f
kernel_ob=510
ramdisk_size=2170944
ramdisk_sb=1091
ramdisk_ob=1d10
mtd=mtdparts=W25q128-flash.0:512k(uboot),64k(dtb),3072k(kernel),4224k(initrd),64k(user),-@0(full)

#end
[i] save firmwares/orange_pi_zero_hyphop_mizy_spi_flash_demo-8M.bin 8388608 bytes
[i] save firmwares/orange_pi_zero_hyphop_mizy_spi_flash_demo-8M+8192-mmc.bin 8396800 bytes

=cut

